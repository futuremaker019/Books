## 퀵 정렬

- 퀵 정렬은 가장 빠른 알고리즘 중의 하나

<br>

- 학생 수가 8명인 그룹을 키 순서대로 정렬한 모습을 나타낸다.
- 먼저 어느 한 사람의 키를 선택
- 키가 168cm인 학생 A를 선택할 경우 그 학생을 기준으로 학생 A의 키보다 작은 사람의 그룹과 큰 사람의 그룹으로 나뉜다.
- 이때 이 학생 A(그룹을 나누는 기준)를 피벗(pivot)이라고 한다.
- 퀵 정렬은 각 그룹에 대해 피벗 설정과 그룹 나눔을 반복하며 모든 그룹이 1명이 되면 정렬을 마친다.

<br>

### 배열을 두 그룹으로 나누기

- 피벗은 6으로 정한다. 피벗은 x, 왼쪽 끝 요소의 인덱스 pl을 왼쪽 커서, 오른쪽 끝 요소의 인덱스 pr을 오른쪽 커서라고 정한다.

<br>

| <strong style='color:red'>pl</strong> |     |     |     | x   |     |     |     | <strong style='color:blue'>pr</strong> |
| ------------------------------------- | --- | --- | --- | --- | --- | --- | --- | -------------------------------------- |
| <strong style='color:red'>5</strong>  | 7   | 1   | 4   | 6   | 2   | 3   | 9   | <strong style='color:blue'>8</strong>  |

<br>

- 그룹을 나누려면 피벗 이하의 요소를 배열 왼쪽으로, 이상의 요소를 배열 오른쪽으로 옮겨야 한다.
- 그러려면 아래 작업을 수행해야 한다.

```
1. a[pl] >= x 가 성립하는 요소를 찾을 때까지 pl을 오른쪽으로 스캔한다.
2. a[pr] <= x 가 성립하는 요소를 찾을 때까지 pr을 왼쪽으로 스캔한다.
```

- 피벗값을 기준으로 피벗값보다 큰 값을 피벗 이하의 요소와 비교하여 찾아낸다.
- 피벗값을 기준으로 피벗값보다 작은 값을 피벗 이상의 요소와 비교하여 찾아낸다.
- 요소가 찾아지면 교환한다.
- 피벗과 피벗값보다 작은 값을 피벗 이상의 요소를 찾으면 교환한다.

<br>

- pl과 pr이 교차하면 그룹을 나누는 과정이 끝나고 배열은 아래처럼 두 그룹으로 나누어 진다.

```
- 피벗 이하의 그룹 : a[0], ..., a[pl - 1]
- 피벗 이상의 그룹 : a[pr + 1], ... , a[n - 1]
```

- 그룹을 나누는 작업이 끝난 다음 pl > pr + 1인 경우에는 다음과 같은 그룹이 생길 수 있다.

```
피벗과 일치하는 값을 가지는 그룹 : a[pr + 1], ... , a[pl - 1]
```

<br>

- a
  | <strong style='color:red'>pl</strong> | | | | x | | | | <strong style='color:blue'>pr</strong> |
  | ------------------------------------- | --- | --- | --- | --- | --- | --- | --- | -------------------------------------- |
  | <strong style='color:red'>1</strong> | 8 | 7 | 4 | 5 | 2 | 6 | 3 | <strong style='color:blue'>9</strong> |

<br>

- b
  | --> | <strong style='color:red'>pl</strong> | | | x | | | <strong style='color:blue'>pr</strong> | <-- |
  | --- | ------------------------------------- | --- | --- | --- | --- | --- | -------------------------------------- | --- |
  | 1 | <strong style='color:red'>8</strong> | 7 | 4 | 5 | 2 | 6 | <strong style='color:blue'>3</strong> | 9 |

<br>

- c
  | --- | --> | <strong style='color:red'>pl</strong> | | x | <strong style='color:blue'>pr</strong> | <-- | --- | --- |
  | --- | --- | ------------------------------------- | --- | --- | -------------------------------------- | --- | --- | --- |
  | 1 | 3 | <strong style='color:red'>7</strong> | 4 | 5 | <strong style='color:blue'>2</strong> | 6 | 8 | 9 |

<br>

- d
  | --- | --- | --- | --> | <strong style='color:red'>pl</strong><br><strong style='color:blue'>pr</strong> | <-- | --- | --- | --- |
  | --- | --- | --- | --- | ------------------------------------------------------------------------------- | --- | --- | --- | --- |
  | 1 | 3 | 2 | 4 | 5 | 7 | 6 | 8 | 9 |

<br>

- e
  | | | | <strong style='color:blue'>pr</strong> | x | <strong style='color:red'>pl</strong> | | | |
  | --- | --- | --- | -------------------------------------- | --- | ------------------------------------- | --- | --- | --- |
  | 1 | 3 | 2 | 4 | 5 | 7 | 6 | 8 | 9 |

<br>

- `d`는 `pl`, `pr`이 동일한 요소 `a[4]` 위에 있다. 이때 동일한 요소 `a[4]`와 `a[4]`를 교환한다.
- 동일한 값을 교환하지 않게 하기 위해서는 요소를 교환하기전에 `pl`과 `pr`이 동일한 요소 위에 있는지 매번 검사해야한다.

### 퀵 정렬

```java
static void partition(int[] a, int arrLength) {
  int pl = 0;                 // 왼쪽 커서
  int pr = arrLength - 1;     // 오른쪽 커서
  int x = a[arrLength / 2];     // 피벗 (가운데 위치의 값)

  do {
      while (a[pl] < x) pl++;
      while (a[pr] > x) pr--;
      if (pl <= pr) {
          // pl을 파라미터로 던져주고 증가??
          swap(a, pl++, pr--);
      }
  } while (pl <= pr);
}
```

### 4.1. 함수 정의

자바스크립트에서 함수를 생성하는 3가지 방법

- 함수 선언문 (function statement)
- 함수 표현식 (function expression)
- Function() 생성자 함수

<br>

### 4.1.1. 함수 리터럴

자바스크립트에서는 함수도 일반 객체처럼 값으로 취급되므로 객체 리터럴 방식으로 일반 객체를 생성할 수 있다. `함수 리터럴`을 이용해 함수를 생성할 수 있다.

함수 표현식 방법 모두 이런 함수 리터럴 방식으로 함수를 생성한다.

```javascript
// 함수 리터럴을 통한 add() 함수 정의
function add(x, y) {
  return x + y;
}
```

함수 리터럴은 앞 그림과 같이 크게 네 부분으로 구성된다.

1. function 키워드
2. 함수명

   - 함수명은 함수 몸체의 내부 코드에서 자신을 재귀적으로 호출하거나 도는 자바스크립트 디버거가 해당 함수를 구분하는 식별자로 사용된다.
   - 함수명은 선택사항, 함수명이 없는 함수를 익명 함수라고 한다.

3. 매개변수 리스트

   - 매개 변수의 타입은 기술하지 않는다.

4. 함수 몸체

<br>

### 4.1.2. 함수 선언문 방식으로 함수 생성하기

함수 선언문 방식은 앞에서 설명한 함수 리터럴 형태와 같다. 함수 선언문 방식으로 정의된 함수의 경우는 반드시 함수명이 정의되어 있어야 한다.

function 이라는 키워드 사용, 리턴값과 매개변수로 넘기는 값에 변수 타입(int, char등)을 기술하지 않는다.

```javascript
// add() 함수 선언문
function add(x, y) {
  return x + y;
}

console.log(3, 4); // (출력값) 7
```

<br>

### 4.1.3. 함수 표현식으로 함수 생성하기

자바스크립트에서는 함수도 하나의 값처럼 취급된다. (이러한 특징으로 자바스크립트의 함수는 `일급 객체` 라고 한다.) 따라서 함수도 숫자나 문자열처럼 변수에 할당하는 것이 가능하다.

이런 방식으로 함수 리터럴로 하나의 함수를 만들고, 여기서 생성된 함수를 변수에 할당하여 함수를 생성하는 것을 `함수 표현식`이라고 한다.

```javascript
// add() 함수 표현식
var add = function (x, y) {
  return x + y;
};

var plus = add;

console.log(add(3, 4)); // 7
console.log(plus(5, 6)); // 11
```

1. add 변수는 함수 리터럴로 생성한 함수를 참조하는 변수이지, 함수 이름이 아니라는 것에 주의한다. add와 같이 함수가 할당된 변수를 함수 변수라고 부르겠다(?)
2. 함수 변수 add는 함수의 참조값을 가지므로 다른 변수 plus에도 그 값을 그대로 할당할 수 있다.
3. 함수를 호출하기 위해서는 add(3,4)와 같이 호출한다. plus 또한 마찬가지로 함수를 호출한다.
4. add와 plus 함수 변수는 두개의 인자를 더하는 동일한 익명 함수를 `참조`한다.

함수 이름이 포함된 함수 표현식을 기명 함수 표현식이라고 한다. 기명 함수 표현식을 사용 시 주의할 점이 있다.
```javascript
var add = function sum(x, y) {
  return x + y;
}

console.log(add(3, 4));   // 7
console.log(sum(3, 4));   // Uncaught ReferenceError : sum is not defined

// 함수 표현식에서 사용된 함수 이름이 외부 코드에서 접근 불가능하기 때문에 일어난 에러
```

함수 선언문으로 정의한 add() 함수는 자바스크립트 엔진에 의해 다음과 같은 함수 표현식 형태로 변경된다.

```javascript
var add = function add(x, y) {
  return x + y;
};
```

함수 표현식에서는 함수 이름이 선택 사항이지만, 이러한 함수 이름을 이용하면 함수 코드 내부에서 함수 이름으로 함수의 재귀적인 호출 처리가 가능하다.
```javascript
var factorialVar = function factorial(n) {
  if(n <= 1) {
    return 1;
  }
  return n * factorial(n - 1);
}

console.log(factorialVar(3));   // 6
console.log(factorial(3));      // Uncaught ReferenceError: factorial is not defined

// 함수 외부에서는 함수 변수 factorialVar로 함수를 호출했으며, 함수 내부에서 이뤄지는 재귀 호출은 factorial() 함수 이름으로 처리한다.
// 함수명 factorial()으로 함수 외부에서 해당 함수를 호출하지 못해 에러가 발생한다.
```

- function statement와 function expression 에서의 세미콜론
  - 일반적으로 자바스크립트 코드를 작성할 때 함수 선언문 방식으로 선언된 함수의 경우는 함수 긑에 세미콜론을 붙이지 않지만, 함수 표현식 방식의 경우는 세미콜론(;)을 붙이는 것을 권장한다.

<br>

### 4.1.4. Function() 생성자 함수를 통한 함수 생성하기

자바스크립트의 함수도 `Function()`이라는 기본 내장 생성자 함수로부터 생성된 객체라고 볼 수 있다. 함수 선언문이나 함수 표현식 방식도 `Function()` 생성자 함수가 아닌 함수 리터럴 방식으로 함수를 생성하지만, 결국엔 이 또한 내부적으로는 `Function()` 생성자 함수로 함수가 생성된다고 볼 수 있다.

```javascript
// Function() 생성자 함수로 함수를 생성하는 문법
new Function(arg1, arg2, .... , argN, functionBody)

  -  arg1, arg2, ... , argN : 함수의 매개변수
  - functionBody : 함수가 호출 될 때 실행될 코드를 포함한 문자열
```

```javascript
var add = new Function('x', 'y', 'return x + y');
console.log(add(3, 4));
```

### 4.1.5. 함수 호이스팅

함수를 생성하는 방법은 3가지가 있지만 이들 사이에는 동작 방식이 약간 차이가 있다. 그중의 하나가 `함수 호이스팅`이다.

```javascript
add(2, 3);  // 5 -------------------------- 1

// 함수 선언문 형태로 add() 함수 정의 ------- 2
function add(x, y) {
  return x + y;
}

add(3, 4);  // 7 -------------------------- 3
```

- 1. add() 함수가 정의되지 않았음에도 2에 정의된 add() 함수를 호출하는 것이 가능하다. 이것은 함수가 자신이 위치한 코드에 상관없이 함수 선언문 형태로 함수의 유효 범위는 코드의 맨 처음부터 시작한다는 것을 확인할 수 있다. 이것을 함수 호이스팅 이라고 한다.

함수 호이스팅은 함수를 사용하기 전에 반드시 선언해야 한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들수도 있다고 지적하며, 함수 표현식 사용을 권장하고 있다.

```javascript
add(2, 3);  // uncaught type error ----- 1

// 함수 표현식 형태로 add() 함수 정의 ---- 2
var add = function (x, y) { 
  return x + y;
};

add(3, 4);  // 7 ----------------------- 3
```

- 1. add() 함수는 2에서 함수 표현식 형태로 정의되어 있어 호이스팅이 일어나지 않는다. 따라서 3과 같이 함수가 생성된 이후에 호출이 가능하다.

함수 호이스팅이 발생하는 원인은 자바스크립트의 `변수 생성(instantiation)`과 `초기화(initialization)`의 작업이 분리돼서 진행되기 때문이다.